var documenterSearchIndex = {"docs":
[{"location":"#HetDister","page":"Home","title":"HetDister","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for HetDister.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Module to run demographic inference on diploid genomes, under the assumption of panmixia (i.e. the inferred effective population size is half the inverse of the observed mean coalescence rate). See this repo for a demo of how to use it.","category":"page"},{"location":"#Data-form-of-input-and-output","page":"Home","title":"Data form of input and output","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The genome needs to be SNP-called and the genomic distance between consecutive heterozygous positions needs to be computed. Heterozygous positions are the ones with genotype 0/1 or 1/0 (Note that the phase is not important). The input is then a vector containind such distances. Additionally, mutation and recombination rates need to be chosen and passed as input as well.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, suppose you have a .vcf file with called variants you want to analyze. Then you may compute distances between heterozygous SNPs as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CSV\nusing DataFrames\nusing DataFramesMeta\n\nf = \"/myproject/myfavouritespecies.vcf\"\ndf = CSV.read(f, DataFrame, \n    delim='\\t', \n    comment=\"##\",\n    missingstring=[\".\", \"NaN\"],\n    normalizenames=true,\n    ntasks = 1,\n    drop = [:INFO, :ID, :FILTER],\n)\n\n# remove homozygous variants\n@chain df begin\n    @rsubset! (:SampleName[1] == '1' && :SampleName[3] == '0') || (:SampleName[1] == '0' && :SampleName[3] == '1')\nend\n\nils = df.POS[2:end] .- df.POS[1:end-1]\n@assert all(ils .> 0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The demographic model underlying the inference is composed of a variable number of epochs and the population size is constant along each epoch.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The output is a vector of parameters in the form [L, N0, T1, N1, T2, N2, ...] where L is the genome length, N0 is the ancestral population size in the furthermost epoch and extending to the infinite past, the subsequent pairs (T_i N_i) are the duration and size of following epochs going from past to present. This format is referred to as TN vector throughout.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#HetDister.FitOptions-Tuple{Any, Any, Any}","page":"Home","title":"HetDister.FitOptions","text":"FitOptions(Ltot, mu, rho; kwargs...)\n\nConstruct an an object of type FitOptions, requiring  total genome length Ltot in base pairs, mutation rate and recombination rate per base pair per generation.\n\nOptional Arguments\n\nTlow::Number=10, Tupp::Number=1e7: The lower and upper bounds for the duration of epochs.\nNlow::Number=10, Nupp::Number=1e8: The lower and upper bounds for the population sizes.\nlevel::Float64=0.95: The confidence level for the confidence intervals on the parameters estimates.\nsolver: The solver to use for the optimization, default is LBFGS().\nopt: The optimization options, a named tuple which is passed to  Optim.jl. Default has keywords:\niterations = 6000\nallow_f_increases = true\ntime_limit = 60\ng_tol = 5e-8\nshow_warnings = false.\nsmallest_segment::Int=1: The smallest segment size present in the histogram to consider  for the signal search.\nforce::Bool=true: if true try to fit further epochs even when no signal is found.\nmaxnts::Int=10: The maximum number of new time splits to consider when adding a new epoch. Higher is greedier.\nnaive::Bool=true: if true the expected weights are computed using the closed form integral, otherwise using higher order transition probabilities from SMC' theory (slower).\norder::Int=10: maximum number of higher order corrections to use when naive is false, i.e. number of intermediate recombination events plus one.\nndt::Int=800: number of Legendre nodes to use when naive is false.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.FitResult","page":"Home","title":"HetDister.FitResult","text":"struct FitResult\n\nA data structure to store the results of a fit.\n\nSee the introduction for how the model is  parameterized Data form of input and output. Some methods are defined for this type to get the vector of parameters, std errors,  model evidence, etc. See get_para, sds, evd,  pop_sizes, durations.\n\n\n\n\n\n","category":"type"},{"location":"#HetDister.adapt_histogram-Tuple{AbstractVector{<:Integer}}","page":"Home","title":"HetDister.adapt_histogram","text":"adapt_histogram(segments::AbstractVector{<:Integer}; lo::Int=1, hi::Int=50_000_000, nbins::Int=800)\n\nBuild an histogram from segments logbinned between lo and hi with nbins bins.\n\nThe upper limit is adapted to ensure logspacing with the requested nbins.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.compare_mlds-Tuple{AbstractVector{<:Integer}, AbstractVector{<:Integer}}","page":"Home","title":"HetDister.compare_mlds","text":"compare_mlds(segs1::Vector{Int}, segs2::Vector{Int}; lo = 1, hi = 1_000_000, nbins = 200)\n\nBuild two histograms from segs1 and segs2, rescale them for number and average heterozygosity and return four vectors containing respectively common midpoints for bins, the two rescaled weights and variances of the difference between weights.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.compare_models-Tuple{Any}","page":"Home","title":"HetDister.compare_models","text":"compare_models(models)\n\nCompare the models parameterized by FitResults and return the best one. Takes an iterable of FitResult as input.\n\nTheoretical explanation\n\nTBD\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.compute_residuals-Tuple{StatsBase.Histogram, Float64, Float64, Vector}","page":"Home","title":"HetDister.compute_residuals","text":"compute_residuals(h::Histogram, mu, rho, TN::Vector; naive=false)\n\nCompute the residuals between the observed and expected weights.\n\nOptional arguments\n\nnaive::Bool=false: if true the expected weights are computed using the closed form integral, otherwise using higher order transition probabilities from SMC' theory.\norder::Int=10: maximum number of higher order corrections to use when naive is false, i.e. number of intermediate recombination events plus one.\nndt::Int=800: number of Legendre nodes to use when naive is false.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.compute_residuals-Tuple{StatsBase.Histogram, StatsBase.Histogram}","page":"Home","title":"HetDister.compute_residuals","text":"compute_residuals(h1::Histogram, h2::Histogram)\n\nWhen two histograms are given the std error of the difference is used for normalization.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.demoinfer-Tuple{AbstractVector{<:Integer}, AbstractRange{<:Integer}, Float64, Float64}","page":"Home","title":"HetDister.demoinfer","text":"demoinfer(segments::AbstractVector{<:Integer}, epochrange::AbstractRange{<:Integer}, mu::Float64, rho::Float64; kwargs...)\n\nMake an histogram with IBS segments and infer demographic histories with piece-wise constant epochs where the number of epochs is epochrange.\n\nReturn a named tuple which contains a vector of FitResult in the field fits (see FitResult).\n\nOptional Arguments\n\nfop::FitOptions = FitOptions(sum(segments), mu, rho): the fit options, see FitOptions.\nlo::Int=1: The lowest segment length to be considered in the histogram\nhi::Int=50_000_000: The highest segment length to be considered in the histogram\nnbins::Int=400: The number of bins to use in the histogram\niters::Int=10: The number of iterations to perform. It might converge earlier\nsetorder::Bool=true: the order at which the SMC' approximation is truncated will be set automatically according to the cutoff\ncutoff=2e-5: when setorder a fraction of segments smaller than cutoff will be ignored to set the order \n\n\n\n\n\n","category":"method"},{"location":"#HetDister.demoinfer-Union{Tuple{E}, Tuple{T}, Tuple{StatsBase.Histogram{T, 1, E}, AbstractRange{<:Integer}, FitOptions}} where {T<:Integer, E<:Tuple{AbstractVector{<:Integer}}}","page":"Home","title":"HetDister.demoinfer","text":"demoinfer(h::Histogram, epochrange, fop::FitOptions; iters=15, reltol=1e-2, corcut=4)\ndemoinfer(h, epochs, fop; iters=15, reltol=1e-2, corcut=4)\n\nTake an histogram of IBS segments, fit options, and infer demographic histories with piece-wise constant epochs where the number of epochs is epochrange. See FitOptions. Return a named tuple which contains a vector of FitResult in the field fits (see FitResult).\n\nIf epochrange is a integer, then it fits only the model with that number of epochs. Return a named tuple with a FitResult object in the field f.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.durations-Tuple{FitResult}","page":"Home","title":"HetDister.durations","text":"durations(fit::FitResult)\n\nReturn the fitted durations of the epochs.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.evd-Tuple{FitResult}","page":"Home","title":"HetDister.evd","text":"evd(fit::FitResult)\n\nReturn the evidence of the fit.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.get_para-Tuple{FitResult}","page":"Home","title":"HetDister.get_para","text":"pars(fit::FitResult)\n\nReturn the parameters of the fit.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.pop_sizes-Tuple{FitResult}","page":"Home","title":"HetDister.pop_sizes","text":"pop_sizes(fit::FitResult)\n\nReturn the fitted population sizes, from past to present.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.pre_fit-Union{Tuple{E}, Tuple{T}, Tuple{StatsBase.Histogram{T, 1, E}, Int64, Float64, Float64, Int64, Int64, Number}} where {T<:Integer, E<:Tuple{AbstractVector{<:Integer}}}","page":"Home","title":"HetDister.pre_fit","text":"pre_fit(h::Histogram, nfits, mu, rho, order, Ltot; require_convergence=true)\npre_fit!(fop::FitOptions, h::Histogram, nfits; require_convergence=true)\n\nPreliminarily fit h with an approximate model of piece-wise constant  epochs for each number of epochs from 1 to nfits.\n\nWith the first signature it initializes the fit options to default. See FitOptions for how to specify them. Otherwise it modifies fop in place to adapt it to all the requested epochs. The mutation rate mu and recombination rate rho are assumed to be per base pairs per generation and the total length of the genome Ltot is in base pairs. Return a  vector of FitResult, one for each number of epochs, see also FitResult.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.sds-Tuple{FitResult}","page":"Home","title":"HetDister.sds","text":"sds(fit::FitResult)\n\nReturn the standard deviations of the parameters of the fit.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.Spectra.laplacekingman-Tuple{Real, Real, AbstractVector{<:Real}}","page":"Home","title":"HetDister.Spectra.laplacekingman","text":"laplacekingman(r, mu, TN)\n\nCompute the approximate number of segments of length r  using the Laplace transform of the Kingman coalescent at frequency 2mu r, given mutation rate mu and population size history TN.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.Spectra.mldsmcp-NTuple{5, Any}","page":"Home","title":"HetDister.Spectra.mldsmcp","text":"mldsmcp(rs, edges, mu, rho, TN; order = 10, ndt = 800)\n\nCompute the expected number of segments with length in each bin defined by edges, given the midpoints rs, mutation rate mu, recombination rate rho, and population size history TN.\n\nThe computation uses the SMC' higher order transition probabilities with order maximum number of intermediate recombination events plus one, and ndt Legendre nodes for the numerical integration.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To run the package, first install julia (here). To create a local environment with the package cd into your work directory and  launch julia, then:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg; Pkg.activate(\".\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pkg.Registry.add(RegistrySpec(url = \"https://github.com/ArndtLab/JuliaRegistry.git\"))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pkg.add(\"HetDister\",\"HistogramBinnings\",\"CSV\",\"DataFrames\")\nusing HetDister, HistogramBinnings, CSV, DataFrames","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The tool require three inputs: a (binned) vector of IBS segments lengths, a mutation rate and  a recombination rate (both per bp per generation).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"data = CSV.read(\"path\", header=0, DataFrame; delim=\"\\t\")\nh_obs = HistogramBinnings.Histogram(LogEdgeVector(lo = 30, hi = 1_000_000, nbins = 200));\nappend!(h_obs, data[:,1])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can read a vector from a .csv file (first line) and then create an histogram with it.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Set a value for the rates and run the inference:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"mu = 2.36e-8\nrho = 1e-8\nLtot = sum(data[:,1])\nnepochs = 3\nres, chains = demoinfer(h_obs, nepochs, mu, rho, Ltot)","category":"page"}]
}
