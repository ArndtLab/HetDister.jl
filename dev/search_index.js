var documenterSearchIndex = {"docs":
[{"location":"diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"Let's say that we inferred some demographic models and we have  obtained the most probable as explained in the Tutorial \n\nresults = demoinfer(segments, 1:8, mu, rho)\nbest = compare_models(results.fits)\n\nFirst we can print\n\nbest.converged\n\nwhich indicates whether the maximum likelihood optimization converged. If that is not the case, we can inspect further\n\nbest.opt.optim_result.original\n\nto get more details and decide whether this flag is correct. In case the non convergence is true, a more greedy search might be needed (see FitOptions) and larger number of iterations and/or optimization time allowed.\n\nWe can also compute z-score residuals to assess goodness of fit\n\nwth = wth = yth .* diff(h.edges[1])\nresid = (h.weights .- wth) ./ sqrt.(wth)\n\nBecause the probabilistic model is Poisson, it might be that bins in the tail have a skewed distribution of residuals, but the others should closely follow a standard normal. We can also assess the correlation structure of neighboring residuals\n\nps = HetDister.residstructure(resid)\n\nThis function return a vector of right tail p values from t-tests for correlation of neighbouring residuals (see the function doc).","category":"section"},{"location":"#HetDister","page":"Home","title":"HetDister","text":"Documentation for HetDister.\n\nModule to run demographic inference on diploid genomes, under the assumption of panmixia.","category":"section"},{"location":"#Data-form-of-input-and-output","page":"Home","title":"Data form of input and output","text":"The genome needs to be SNP-called and the genomic distance between consecutive heterozygous positions needs to be computed. Heterozygous positions are the ones with genotype 0/1 or 1/0 (Note that the phase is not important). The input is then a vector containind such distances. Additionally, mutation and recombination rates need to be chosen and passed as input as well. See Tutorial for more details on preparing input data.\n\nThe demographic model underlying the inference is composed of a variable number of epochs and the population size is constant along each epoch.\n\nThe output is a vector of parameters in the form [L, N0, T1, N1, T2, N2, ...] where L is the total sequence length, N0 is the ancestral population size in the furthermost epoch and extending to the infinite past, the subsequent pairs (T_i N_i) are the duration and size of following epochs going from past to present. This format is referred to as TN vector throughout. The length L should match the input sequence length and is floating to improve the fit.\n\n","category":"section"},{"location":"#HetDister.FitOptions-NTuple{4, Any}","page":"Home","title":"HetDister.FitOptions","text":"FitOptions(Ltot, nhet, mu, rho; kwargs...)\n\nConstruct an an object of type FitOptions, requiring  total genome length Ltot in base pairs, number of heterozygous sites nhet, mutation rate mu and recombination rate rho per base pair per generation.\n\nOptional Arguments\n\nTlow::Number=10, Tupp::Number=1e7: The lower and upper bounds for the duration of epochs.\nNlow::Number=10, Nupp::Number=1e8: The lower and upper bounds for the population sizes.\nlevel::Float64=0.95: The confidence level for the confidence intervals on the parameters estimates.\nsolver: The solver to use for the optimization, default is LBFGS().\nforce::Bool=true: if true try to fit further epochs even when no signal is found.\nmaxnts::Int=5: The maximum number of new time splits to consider when adding a new epoch. Higher is greedier.\norder::Int=0: maximum number of higher order SMC' corrections to account for (i.e. number of intermediate recombination events plus one). When zero, it is set automatically.\nndt::Int=0: number of Legendre nodes to use for numerical integration. When zero, it is set automatically.\nlocut::Int=1: index of the first histogram bin to consider in the fit.\n\nOptim Arguments\n\nAdditional keywords are passed to Optimization.solve, see Optimization.jl. and the specific Optim.jl section, which is the default optimizer. Defaults are:\n\nmaxiters = 6000\nmaxtime = 60\ng_tol = 5e-8\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.FitResult","page":"Home","title":"HetDister.FitResult","text":"struct FitResult\n\nA data structure to store the results of a fit.\n\nSee the introduction for how the model is  parameterized Data form of input and output. Some methods are defined for this type to get the vector of parameters, std errors,  model evidence, etc. See get_para, sds, evd,  pop_sizes, durations.\n\n\n\n\n\n","category":"type"},{"location":"#HetDister.adapt_histogram-Tuple{AbstractVector{<:Integer}}","page":"Home","title":"HetDister.adapt_histogram","text":"adapt_histogram(segments::AbstractVector{<:Integer}; lo::Int=1, hi::Int=50_000_000, nbins::Int=0, tailthr::Int=0)\n\nBuild an histogram from segments logbinned between lo and hi with nbins bins. nbins is automatically determined by default.\n\nThe upper limit is adapted to ensure logspacing with the requested nbins. The adaptive strategy is such that the last bin has at least tailthr segments.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.compare_mlds!-NTuple{4, Any}","page":"Home","title":"HetDister.compare_mlds!","text":"compare_mlds!(h1::Histogram, h2::Histogram, theta1::Float64, theta2::Float64)\n\nThe same as compare_mlds, except that it takes two histograms and mutates them. Return values are the same as compare_mlds.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.compare_mlds-Tuple{AbstractVector{<:Integer}, AbstractVector{<:Integer}}","page":"Home","title":"HetDister.compare_mlds","text":"compare_mlds(segs1::Vector{Int}, segs2::Vector{Int}; lo = 1, hi = 1_000_000, nbins = 200)\n\nBuild two histograms from segs1 and segs2, rescale them for number and average heterozygosity and return four vectors containing respectively common midpoints for bins, the two rescaled weights and variances of the difference between weights.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.compare_models","page":"Home","title":"HetDister.compare_models","text":"compare_models(models[, mask])\n\nCompare the models parameterized by FitResults and return the best one. Takes an iterable of FitResult as input and optionally a boolean mask to reflect prior knowledge on models to discard.\n\n\n\n\n\n","category":"function"},{"location":"#HetDister.compute_residuals-Tuple{StatsBase.Histogram, Float64, Float64, Vector}","page":"Home","title":"HetDister.compute_residuals","text":"compute_residuals(h::Histogram, mu, rho, TN::Vector; naive=false)\n\nCompute the residuals between the observed and expected weights.\n\nOptional arguments\n\nnaive::Bool=false: if true the expected weights are computed using the closed form integral, otherwise using higher order transition probabilities from SMC' theory.\norder::Int=10: maximum number of higher order corrections to use when naive is false, i.e. number of intermediate recombination events plus one.\nndt::Int=800: number of Legendre nodes to use when naive is false.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.compute_residuals-Tuple{StatsBase.Histogram, StatsBase.Histogram}","page":"Home","title":"HetDister.compute_residuals","text":"compute_residuals(h1::Histogram, h2::Histogram)\n\nWhen two histograms are given the std error of the difference is used for normalization.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.demoinfer-Tuple{AbstractVector{<:Integer}, AbstractRange{<:Integer}, Float64, Float64}","page":"Home","title":"HetDister.demoinfer","text":"demoinfer(segments::AbstractVector{<:Integer}, epochrange::AbstractRange{<:Integer}, mu::Float64, rho::Float64; kwargs...)\n\nMake an histogram with IBS segments and infer demographic models with piece-wise constant epochs where the number of epochs is epochrange.\n\nReturn a named tuple which contains the fields:\n\nfits: a vector of FitResult (see FitResult)\nchains: a vector of vectors of FitResult, one for each iteration of the correction procedure, and one chain per model\ncorrections: a vector of vectors of corrections, one for each iteration of the correction procedure, and one vector of corrections per model. Corrections are histogram counts, therefore they have the same shape.\nh_obs: the histogram of the observed segments\nh_mods: a vector of modified histograms, one for each model, with higher order corrections applied.\nyth: a vector of vectors of the expected weights, one for each model\ndeltas: a vector of vectors of the maximum absolute difference between corrections in consecutive iterations, and for each model.\nconv: a vector of booleans, one for each model, indicating whether the maximum iterations were reached (false) or whether the procedure  converged before (true).\n\nOptional Arguments\n\nfop::FitOptions = FitOptions(sum(segments), mu, rho): the fit options, see FitOptions.\nlo::Int=1: The lowest segment length to be considered in the histogram\nhi::Int=50_000_000: The highest segment length to be considered in the histogram\nnbins::Int=fop.ndt: The number of bins to use in the histogram\niters::Int=20: The number of iterations to perform. It might converge earlier\nreltol::Float64=1e-2: The relative tolerance to use for convergence, i.e. the maximum absolute difference between corrections in consecutive iterations.\ncorcut::Int=fop.locut-1: The index of the last histogram bin to apply corrections to.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.demoinfer-Union{Tuple{E}, Tuple{T}, Tuple{StatsBase.Histogram{T, 1, E}, AbstractRange{<:Integer}, FitOptions}} where {T<:Integer, E<:Tuple{AbstractVector{<:Integer}}}","page":"Home","title":"HetDister.demoinfer","text":"demoinfer(h::Histogram, epochrange, fop::FitOptions; iters=20, reltol=1e-2, corcut=fop.locut-1, finalize=false)\ndemoinfer(h, epochs, fop; iters=20, reltol=1e-2, corcut=fop.locut-1, finalize=false)\n\nTake an histogram of IBS segments, fit options, and infer demographic models with piece-wise constant epochs where the number of epochs is epochrange. Return a named tuple as above.\n\nIf epochrange is a integer, then it fits only the model with that number of epochs. In this case the returned named tuple contains only one element per field, instead of a vector.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.durations-Tuple{FitResult}","page":"Home","title":"HetDister.durations","text":"durations(fit::FitResult)\n\nReturn the fitted durations of the epochs.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.evd-Tuple{FitResult}","page":"Home","title":"HetDister.evd","text":"evd(fit::FitResult)\n\nReturn the evidence of the fit.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.get_covar-Tuple{FitResult}","page":"Home","title":"HetDister.get_covar","text":"get_covar(fit::FitResult)\n\nReturn the covariance matrix of the parameters of the fit, computed as the inverse of the likelihood Hessian at the optimum.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.get_para-Tuple{FitResult}","page":"Home","title":"HetDister.get_para","text":"pars(fit::FitResult)\n\nReturn the parameters of the fit.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.pop_sizes-Tuple{FitResult}","page":"Home","title":"HetDister.pop_sizes","text":"pop_sizes(fit::FitResult)\n\nReturn the fitted population sizes, from past to present.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.pre_fit!-Union{Tuple{E}, Tuple{T}, Tuple{FitOptions, StatsBase.Histogram{T, 1, E}, Int64}} where {T<:Integer, E<:Tuple{AbstractVector{<:Integer}}}","page":"Home","title":"HetDister.pre_fit!","text":"pre_fit!(fop::FitOptions, h::Histogram, nfits)\n\nPreliminarily fit h with an approximate model of piece-wise constant  epochs for each number of epochs from 1 to nfits.\n\nSee FitOptions for how to specify them. It modifies fop in place to adapt it to all the requested epochs. Return a vector of FitResult, one for each number of epochs, see also FitResult.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.residstructure-Tuple{AbstractVector{<:Real}}","page":"Home","title":"HetDister.residstructure","text":"residstructure(residuals::AbstractVector{<:Real}; frame::Int = length(residuals)รท20)\n\nCompute the p-values for the correlation between adjacent residuals in a sliding window of size frame. The p-value is the right tail of the t-distribution.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.sample_model_epochs!-Union{Tuple{E}, Tuple{T}, Tuple{FitOptions, StatsBase.Histogram{T, 1, E}, AbstractVector{<:Real}}} where {T<:Integer, E<:Tuple{AbstractVector{<:Integer}}}","page":"Home","title":"HetDister.sample_model_epochs!","text":"sample_model_epochs!(options::FitOptions, h::Histogram{T,1,E}, init::AbstractVector{<:Real}; nsamples = 10_000, findmode = false)\n\nSample nsamples from the posterior distribution of the parameters, starting from initial point init.\n\nRequires the observed histogram h and the fit options options. Return a Chains object from the MCMCDiagnostics module of Turing, which contains the samples from the posterior distribution. If findmode is true, the function will first find the mode of the posterior distribution using optimization, and then use that as the initial point for sampling. Otherwise, it will use the provided init as the initial point for sampling.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.sds-Tuple{FitResult}","page":"Home","title":"HetDister.sds","text":"sds(fit::FitResult)\n\nReturn the standard deviations of the parameters of the fit.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.setinit!-Tuple{FitOptions, AbstractVector{Float64}}","page":"Home","title":"HetDister.setinit!","text":"setinit!(fop::FitOptions, init::AbstractVector{Float64})\n\nSet the initial vector of parameters for the optimization which takes the FitOptions object fop.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.Spectra.laplacekingman-Tuple{Real, Real, AbstractVector{<:Real}}","page":"Home","title":"HetDister.Spectra.laplacekingman","text":"laplacekingman(r, mu, TN)\n\nCompute the approximate number of segments of length r  using the Laplace transform of the Kingman coalescent at frequency 2mu r, given mutation rate mu and population size history TN.\n\n\n\n\n\n","category":"method"},{"location":"#HetDister.Spectra.mldsmcp-NTuple{5, Any}","page":"Home","title":"HetDister.Spectra.mldsmcp","text":"mldsmcp(rs, edges, mu, rho, TN; order = 10, ndt = 800)\n\nCompute the expected number of segments with length in each bin defined by edges, given the midpoints rs, mutation rate mu, recombination rate rho, and population size history TN.\n\nThe computation uses the SMC' higher order transition probabilities with order maximum number of intermediate recombination events plus one, and ndt Legendre nodes for the numerical integration.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"To run the package, first install julia (here). To create a local environment with the package cd into your work directory and  launch julia, then install the package (and other useful packages to handle the data):\n\nusing Pkg; Pkg.activate(\".\")\n\nPkg.Registry.add(RegistrySpec(url = \"https://github.com/ArndtLab/JuliaRegistry.git\"))\n\nPkg.add(\"HetDister\",\"HistogramBinnings\",\"CSV\",\"DataFrames\",\"DataFramesMeta\")\n\nYou can now load the installed packages:\n\nusing HetDister, HistogramBinnings, CSV, DataFrames, DataFramesMeta","category":"section"},{"location":"tutorial/#Preparing-input-data","page":"Tutorial","title":"Preparing input data","text":"For example, suppose you have a .vcf file with called variants you want to analyze. Then, in the most basic case, you may compute distances between heterozygous SNPs as follows:\n\nf = \"/myproject/myfavouritespecies.vcf\"\ndf = CSV.read(f, DataFrame, \n    delim='\\t', \n    comment=\"##\",\n    missingstring=[\".\", \"NaN\"],\n    normalizenames=true,\n    ntasks = 1,\n    drop = [:INFO, :ID, :FILTER],\n)\n\n# remove homozygous variants\n@chain df begin\n    @rsubset! (:SampleName[1] == '1' && :SampleName[3] == '0') || (:SampleName[1] == '0' && :SampleName[3] == '1')\nend\n\nils = df.POS[2:end] .- df.POS[1:end-1]\n@assert all(ils .> 0)\n\nNow we have a vector of intervals ils.","category":"section"},{"location":"tutorial/#Fitting-and-comparing-demographic-models","page":"Tutorial","title":"Fitting and comparing demographic models","text":"The tool require three inputs: a vector of IBS segments lengths, a mutation rate and  a recombination rate (both per bp per generation). Additionally, we need to choose a range of demographic models with epochs of piecewise constant effective size.\n\nIn the simplest use case we can just call\n\nmu = 1e-8\nrho = 1e-8\nresults = demoinfer(ils, 1:8, mu, rho)\n\nand the 8 models will be saved in results.fits. Then we can obtain the most probable model in the set with\n\nbest = compare_models(results.fits)","category":"section"},{"location":"tutorial/#More-advanced-options","page":"Tutorial","title":"More advanced options","text":"First IBS spectrum is obtained as an histogram and the binning can be  controlled by the function adapt_histogram and it keyword arguments\n\nh = adapt_histogram(ils)\nmu = 1e-8\nrho = 1e-8\n\nThen we set up the FitOptions object that contains several parameters for the optimization. We stick with default values and only initialize with the three required inputs:\n\nfop = FitOptions(sum(ils), length(ils), mu, rho)\n\nAnd we fit 8 different model, with a number of epochs in the range 1 to 8:\n\nresults = demoinfer(h_obs, 1:8, fop)\n\nThe fitted models can be accessed with results.fits.\n\nSee Diagnostics to inspect the result and assess goodness of fit and optimization convergence.","category":"section"}]
}
