var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = DemoInfer","category":"page"},{"location":"#DemoInfer","page":"Home","title":"DemoInfer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DemoInfer.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Module to run demographic inference on diploid genomes, under the assumption of panmixia (i.e. the inferred effective population size is half the inverse of the observed mean coalescence rate). See this repo for a demo of how to use it.","category":"page"},{"location":"#Data-form-of-input-and-output","page":"Home","title":"Data form of input and output","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The genome needs to be SNP-called and the genomic distance between consecutive heterozygous sites needs to be computed. The input is then a vector containind such distances. Additionally, mutation and recombination rates need to be chosen and passed as input as well.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The demographic model underlying the inference is composed of a variable number of epochs and the population size is constant along each epoch.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The output is a vector of parameters in the form [L, N0, T1, N1, T2, N2, ...] where L is the genome length, N0 is the ancestral population size in the infinite past and the subsequent pairs (T_i N_i) are the duration and size of following epochs going from past to present. This format is referred to as TN vector throughout.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [DemoInfer]","category":"page"},{"location":"#DemoInfer.FitResult","page":"Home","title":"DemoInfer.FitResult","text":"struct FitResult\n\nA data structure to store the results of a fit.\n\nSome methods are defined for this type to get the vector of parameters, std errors,  model evidence, etc. See get_para, sds, evd,  pop_sizes, durations.\n\n\n\n\n\n","category":"type"},{"location":"#DemoInfer.compare_models-Tuple{Vector{FitResult}}","page":"Home","title":"DemoInfer.compare_models","text":"compare_models(models::Vector{FitResult})\n\nCompare the models parameterized by FitResults and return the best one.\n\nTheoretical explanation\n\nTBD\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.demoinfer-Tuple{StatsBase.Histogram, Int64, Float64, Float64, Number, Vector{Float64}}","page":"Home","title":"DemoInfer.demoinfer","text":"demoinfer(h_obs::Histogram, nepochs::Int, mu::Float64, rho::Float64, Ltot::Number; kwargs...)\ndemoinfer(h_obs, nepochs, mu, rho, Ltot, init::Vector{Float64}; kwargs...)\n\nFit iteratively h_obs with a demographic history of piece-wise constant nepochs.\n\nReturn a vector of FitResult, see FitResult, mu and rho are the mutation and recombination rates, respectively, per base pair per generation and Ltot is the total length of the genome, in base pairs. Optional argument init can be used to provide an initial point for the iterations.\n\nArguments\n\niters::Int = 5: The number of iterations to perform. Suggested value is at least 5, annealing plays a role.\nburnin::Int = 3: The number of iterations to discard as burnin. Notice that in general with no annealing,   i.e. Flat(), already the first iteration is a good sample.\nallow_boundary::Bool=false: If true, the function will allow the fit to reach the upper \n\nboundaries of populations sizes. This can be useful if structure is expected because epochs of separation between two subpopulations show up as a higher population size (smaller coalescence rate).\n\nlevel::Float64=0.95: The confidence level for the confidence intervals on the parameters estimates.\nTlow::Int=10: The lower bound for the duration of epochs.\nNlow::Int=10, Nupp::Int=100000: The lower and upper bounds for the population sizes.\nsmallest_segment::Int=30: The smallest segment size to consider for the optimization.\nannealing = Sq(): correction is computed by simulating a genome of length factor times the length of\n\nthe input genome. At each iteration the factor is changed according to the annealing function. It can be Flat(), Lin() or Sq(). It can be a user defined function with signature (L, it) -> factor with L the genome length and it the iteration index.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.durations-Tuple{FitResult}","page":"Home","title":"DemoInfer.durations","text":"durations(fit::FitResult)\n\nReturn the fitted durations of the epochs.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.estimate_nepochs-Tuple{StatsBase.Histogram, Float64, Number}","page":"Home","title":"DemoInfer.estimate_nepochs","text":"estimate_nepochs(h::Histogram, mu::Float64, Ltot::Number; max_nepochs::Int = 10, kwargs...)\n\nEstimate the number of epochs needed to fit the histogram h.\n\nThe mutation rate mu is assumed to be per base pairs per generation,  and the total length of the genome Ltot is in base pairs.\n\nThe optional argument max_nepochs defines the maximum number of epochs that are explored, while the other keyword arguments are passed to pre_fit.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.evd-Tuple{FitResult}","page":"Home","title":"DemoInfer.evd","text":"evd(fit::FitResult)\n\nReturn the evidence of the fit.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.get_chain-Tuple{FitResult}","page":"Home","title":"DemoInfer.get_chain","text":"get_chain(fit::FitResult)\n\nReturn two matrices containing the chain of fitted parameters and std errors respectively.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.get_para-Tuple{FitResult}","page":"Home","title":"DemoInfer.get_para","text":"pars(fit::FitResult)\n\nReturn the parameters of the fit.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.get_sim!-Tuple{Vector, StatsBase.Histogram, Float64, Float64}","page":"Home","title":"DemoInfer.get_sim!","text":"get_sim!(params::Vector, h::Histogram, mu::Float64, rho::Float64; factor = 1)\n\nSimulate a population according to the demographic parameters in params and stores  the IBS segments in the h.\n\nArguments\n\n'params': vector of the form [L, N0, T1, N1, T2, N2] where L is the genome length,   N0 is the ancestral population size and successive pairs of Ti and Ni are the   durations and sizes of subsequent epochs.\nfactor: determine how many genomes are simulated and averaged\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.pop_sizes-Tuple{FitResult}","page":"Home","title":"DemoInfer.pop_sizes","text":"pop_sizes(fit::FitResult)\n\nReturn the fitted population sizes, from past to present.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.pre_fit-Tuple{StatsBase.Histogram, Int64, Float64, Number}","page":"Home","title":"DemoInfer.pre_fit","text":"pre_fit(h::Histogram, nfits::Int, mu::Float64, Ltot::Number; kwargs...)\n\nPreliminarily fit h with an approximate model of piece-wise constant nepochs.\n\nThe mutation rate mu is assumed to be per base pairs per generation and the total length of the genome Ltot is in base pairs. The fit approximate the histogram with more and more epochs up to nepochs, so the result is a vector of FitResult, one for each number of epochs.\n\nSee also FitResult.\n\nArguments\n\nTlow::Int=10: The lower bound for the duration of epochs.\nNlow::Int=10, Nupp::Int=100000: The lower and upper bounds for the population sizes.\nsmallest_segment::Int=30: The smallest segment size to consider for the optimization,\n\nsame as in demoinfer.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.sds-Tuple{FitResult}","page":"Home","title":"DemoInfer.sds","text":"sds(fit::FitResult)\n\nReturn the standard deviations of the parameters of the fit.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To run the package, first install julia (here). To create a local environment with the package cd into your work directory and  launch julia, then:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg; Pkg.activate(\".\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pkg.Registry.add(RegistrySpec(url = \"https://github.com/ArndtLab/JuliaRegistry.git\"))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pkg.add(\"DemoInfer\",\"HistogramBinnings\",\"CSV\",\"DataFrames\")\nusing DemoInfer, HistogramBinnings, CSV, DataFrames","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The tool require three inputs: a (binned) vector of IBS segments lengths, a mutation rate and  a recombination rate (both per bp per generation).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"data = CSV.read(\"path\", header=0, DataFrame; delim=\"\\t\")\nh_obs = HistogramBinnings.Histogram(LogEdgeVector(lo = 30, hi = 1_000_000, nbins = 200));\nappend!(h_obs, data[:,1])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can read a vector from a .csv file (first line) and the create an histogram with it.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Set a value for the rates and run the inference:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"mu = 2.36e-8\nrho = 1e-8\nLtot = sum(data[:,1])\nnepochs = 3\nres, chains = demoinfer(h_obs, nepochs, mu, rho, Ltot)","category":"page"}]
}
