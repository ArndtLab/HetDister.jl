var documenterSearchIndex = {"docs":
[{"location":"#DemoInfer","page":"Home","title":"DemoInfer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DemoInfer.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Module to run demographic inference on diploid genomes, under the assumption of panmixia (i.e. the inferred effective population size is half the inverse of the observed mean coalescence rate). See this repo for a demo of how to use it.","category":"page"},{"location":"#Data-form-of-input-and-output","page":"Home","title":"Data form of input and output","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The genome needs to be SNP-called and the genomic distance between consecutive heterozygous positions needs to be computed. Heterozygous positions are the ones with genotype 0/1 or 1/0 (Note that the phase is not important). The input is then a vector containind such distances. Additionally, mutation and recombination rates need to be chosen and passed as input as well.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, suppose you have a .vcf file with called variants you want to analyze. Then you may compute distances between heterozygous SNPs as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CSV\nusing DataFrames\nusing DataFramesMeta\n\nf = \"/myproject/myfavouritespecies.vcf\"\ndf = CSV.read(f, DataFrame, \n    delim='\\t', \n    comment=\"##\",\n    missingstring=[\".\", \"NaN\"],\n    normalizenames=true,\n    ntasks = 1,\n    drop = [:INFO, :ID, :FILTER],\n)\n\n# remove homozygous variants\n@chain df begin\n    @rsubset! (:SampleName[1] == '1' && :SampleName[3] == '0') || (:SampleName[1] == '0' && :SampleName[3] == '1')\nend\n\nils = df.POS[2:end] .- df.POS[1:end-1]\n@assert all(ils .> 0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The demographic model underlying the inference is composed of a variable number of epochs and the population size is constant along each epoch.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The output is a vector of parameters in the form [L, N0, T1, N1, T2, N2, ...] where L is the genome length, N0 is the ancestral population size in the furthermost epoch and extending to the infinite past, the subsequent pairs (T_i N_i) are the duration and size of following epochs going from past to present. This format is referred to as TN vector throughout.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#DemoInfer.FitOptions-Tuple{Number}","page":"Home","title":"DemoInfer.FitOptions","text":"FitOptions(Ltot::Number; kwargs...)\n\nConstruct an an object of type FitOptions, requiring total genome length Ltot in base pairs.\n\nOptional Arguments\n\nTlow::Number=10, Tupp::Number=1e7: The lower and upper bounds for the duration of epochs.\nNlow::Number=10, Nupp::Number=1e8: The lower and upper bounds for the population sizes.\nlevel::Float64=0.95: The confidence level for the confidence intervals on the parameters estimates.\nsolver: The solver to use for the optimization, default is LBFGS().\nopt: The optimization options, a named tuple which is passed to \n\nOptim.jl. Default is has keywords:     - iterations = 6000     - allow_f_increases = true     - time_limit = 60     - g_tol = 5e-8     - show_warnings = false.\n\nsmallest_segment::Int=1: The smallest segment size present in the histogram to consider \n\nfor the signal search.\n\nforce::Bool=false: if true try to fit further epochs even when no signal is found.\nmaxnts::Int=10: The maximum number of new time splits to consider when adding a new epoch.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.FitResult","page":"Home","title":"DemoInfer.FitResult","text":"struct FitResult\n\nA data structure to store the results of a fit.\n\nSome methods are defined for this type to get the vector of parameters, std errors,  model evidence, etc. See get_para, sds, evd,  pop_sizes, durations.\n\n\n\n\n\n","category":"type"},{"location":"#DemoInfer.adapt_histogram-Tuple{AbstractVector{<:Integer}}","page":"Home","title":"DemoInfer.adapt_histogram","text":"adapt_histogram(segments::AbstractVector{<:Integer}; lo::Int=1, hi::Int=50_000_000, nbins::Int=200)\n\nBuild an histogram from segments logbinned between lo and hi with nbins bins (see HistogramBinnings.jl).\n\nThe upper limit is adapted to the maximum observed length, so default value is on purpose high.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.compare_mlds-Tuple{AbstractVector{<:Integer}, AbstractVector{<:Integer}}","page":"Home","title":"DemoInfer.compare_mlds","text":"compare_mlds(segs1::Vector{Int}, segs2::Vector{Int}; lo = 1, hi = 1_000_000, nbins = 200)\n\nBuild two histograms from segs1 and segs2, rescale them for number and average heterozygosity and return four vectors containing respectively common midpoints for bins, the two rescaled weights and variances of the difference between weights.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.compare_models-Tuple{Vector{FitResult}}","page":"Home","title":"DemoInfer.compare_models","text":"compare_models(models::Vector{FitResult})\n\nCompare the models parameterized by FitResults and return the best one.\n\nTheoretical explanation\n\nTBD\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.compute_residuals-Tuple{StatsBase.Histogram, Float64, Vector}","page":"Home","title":"DemoInfer.compute_residuals","text":"compute_residuals(h::Histogram, mu::Float64, TN::Vector)\n\nCompute the residuals between the observed and expected weights.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.compute_residuals-Tuple{StatsBase.Histogram, StatsBase.Histogram}","page":"Home","title":"DemoInfer.compute_residuals","text":"compute_residuals(h1::Histogram, h2::Histogram)\n\nWhen two histograms are given the std error of the difference is used for normalization.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.demoinfer-Tuple{AbstractVector{<:Integer}, UnitRange{Int64}, Float64, Float64}","page":"Home","title":"DemoInfer.demoinfer","text":"demoinfer(segments::AbstractVector{<:Integer}, epochrange::UnitRange{Int}, mu::Float64, rho::Float64; kwargs...)\n\nMake an histogram with IBS segments and infer demographic histories with piece-wise constant epochs where the number of epochs is in epochrange.\n\nReturn a vector of FitResult of length smaller or equal to epochrange,  see FitResult, mu and rho are respectively the mutation  and recombination rates per base pair per generation.\n\nOptional Arguments\n\nfop::FitOptions = FitOptions(sum(segments)): the fit options, see FitOptions.\nlo::Int=1: The lowest segment length to be considered in the histogram\nhi::Int=50_000_000: The highest segment length to be considered in the histogram\nnbins::Int=200: The number of bins to use in the histogram\niters::Int=8: The number of iterations to perform. Currently automatic check for convergence\n\nis not implemented.\n\nannealing=nothing: correction is computed by simulating a genome of length factor times \n\nthe length of the input genome. At each iteration the factor is changed according to the  annealing function. It can be Flat(), Lin() or Sq(). It can be a user defined  function with signature (L, it) -> factor with L the genome length and it the iteration index. By default it is computed adaptively based on the input data, such  that the total expected volume of the histogram is 2e8.\n\ns::Int=1234: The random seed for the random number generator, used to compute the correction.\nrestart::Int=100: The number of iterations after which the fit is restarted with\n\na different seed. Set to a default high number, it should not be needed.\n\ntop::Int=1: the number of fits at chain tail which is averaged for the final estimate.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.demoinfer-Tuple{StatsBase.Histogram, Int64, Float64, Float64, Number, Vector{Float64}}","page":"Home","title":"DemoInfer.demoinfer","text":"demoinfer(h_obs::Histogram, nepochs::Int, mu::Float64, rho::Float64, Ltot::Number, init::Vector{Float64}; kwargs...)\n\nFit iteratively histogram h_obs with a single demographic model  of piece-wise constant nepochs starting from an initial parameter vector init.\n\nReturn a FitResult, see FitResult, above methods fall back to this, which is called on multiple threads if available.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.demoinfer-Union{Tuple{E}, Tuple{T}, Tuple{StatsBase.Histogram{T, 1, E}, UnitRange{Int64}, Float64, Float64, Number}} where {T<:Integer, E<:Tuple{AbstractVector{<:Integer}}}","page":"Home","title":"DemoInfer.demoinfer","text":"demoinfer(h, epochrange, mu, rho, Ltot; kwargs...)\n\nDoes the same as above, but takes a histogram as input and the total length of the IBS segments.\n\nIt is much lighter to distribute the histogram than the vector of segments which may also be streamed directly from disk into the histogram.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.durations-Tuple{FitResult}","page":"Home","title":"DemoInfer.durations","text":"durations(fit::FitResult)\n\nReturn the fitted durations of the epochs.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.evd-Tuple{FitResult}","page":"Home","title":"DemoInfer.evd","text":"evd(fit::FitResult)\n\nReturn the evidence of the fit.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.get_chain-Tuple{FitResult}","page":"Home","title":"DemoInfer.get_chain","text":"get_chain(fit::FitResult)\n\nReturn two matrices containing the chain of fitted parameters and std errors respectively (both as columns).\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.get_para-Tuple{FitResult}","page":"Home","title":"DemoInfer.get_para","text":"pars(fit::FitResult)\n\nReturn the parameters of the fit.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.get_sim!-Tuple{Vector, StatsBase.Histogram, Float64, Float64}","page":"Home","title":"DemoInfer.get_sim!","text":"get_sim!(params::Vector, h::Histogram, mu::Float64, rho::Float64; factor = 1)\n\nSimulate a population according to the demographic parameters in params and stores  the IBS segments in the h.\n\nArguments\n\n'params': vector of the form [L, N0, T1, N1, T2, N2] where L is the genome length,   N0 is the ancestral population size and successive pairs of Ti and Ni are the   durations and sizes of subsequent epochs.\nfactor: determine how many genomes are simulated and averaged\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.pop_sizes-Tuple{FitResult}","page":"Home","title":"DemoInfer.pop_sizes","text":"pop_sizes(fit::FitResult)\n\nReturn the fitted population sizes, from past to present.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.pre_fit-Union{Tuple{E}, Tuple{T}, Tuple{StatsBase.Histogram{T, 1, E}, Int64, Float64, FitOptions}} where {T<:Integer, E<:Tuple{AbstractVector{<:Integer}}}","page":"Home","title":"DemoInfer.pre_fit","text":"pre_fit(h::Histogram, nfits::Int, mu::Float64, Ltot::Number; require_convergence=true)\npre_fit(h::Histogram, nfits::Int, mu::Float64, fop::FitOptions; require_convergence=true)\n\nPreliminarily fit h with an approximate model of piece-wise constant  epochs for each number of epochs from 1 to nfits.\n\nIf given the total length of the genome Ltot it initialize the fit  options to default. See FitOptions for how to specify them. The mutation rate mu is assumed to be per base pairs per generation and the total length of the genome Ltot is in base pairs. Return a  vector of FitResult, one for each number of epochs, see also FitResult.\n\n\n\n\n\n","category":"method"},{"location":"#DemoInfer.sds-Tuple{FitResult}","page":"Home","title":"DemoInfer.sds","text":"sds(fit::FitResult)\n\nReturn the standard deviations of the parameters of the fit.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To run the package, first install julia (here). To create a local environment with the package cd into your work directory and  launch julia, then:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg; Pkg.activate(\".\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pkg.Registry.add(RegistrySpec(url = \"https://github.com/ArndtLab/JuliaRegistry.git\"))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pkg.add(\"DemoInfer\",\"HistogramBinnings\",\"CSV\",\"DataFrames\")\nusing DemoInfer, HistogramBinnings, CSV, DataFrames","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The tool require three inputs: a (binned) vector of IBS segments lengths, a mutation rate and  a recombination rate (both per bp per generation).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"data = CSV.read(\"path\", header=0, DataFrame; delim=\"\\t\")\nh_obs = HistogramBinnings.Histogram(LogEdgeVector(lo = 30, hi = 1_000_000, nbins = 200));\nappend!(h_obs, data[:,1])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can read a vector from a .csv file (first line) and then create an histogram with it.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Set a value for the rates and run the inference:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"mu = 2.36e-8\nrho = 1e-8\nLtot = sum(data[:,1])\nnepochs = 3\nres, chains = demoinfer(h_obs, nepochs, mu, rho, Ltot)","category":"page"}]
}
